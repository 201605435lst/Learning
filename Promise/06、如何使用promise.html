<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /*
    一、API(语法或者前后端交互的接口)
        1、promise构造函数：Promise(exector){}
            (1)excutor函数:执行器{resolve,reject}=>{}
            (2)resolve函数：内部定义成功时我们定义的函数value=>{}
            (3)reject函数：内部定义失败时我们调用的函数reason=>{}
            说明：excutor会在Promise内部立即同步回调，异步操作在执行器中执行

        2、promise.prototype.then方法：（onResolved,onReject）=>{}
    
    */
      // new Promise((resolve, reject) => {
      //   setTimeout(() => {
      //     resolve('返回成功的数据');
      //     // reject("返回失败 的数据")
      //   }, 2000);
      // })
      //   .then(value => {
      //     console.log('onResolved()1' + value);
      //   })
      //   .catch(reason => {
      //     console.log('onRejected()1' + reason);
      //   });
      // 产生一个promise值为1的对象
      // const p1 = new Promise((resolve, reject) => {
      //   resolve(1);
      // });
      const p1 = Promise.resolve(1);
      const p2 = Promise.resolve(2);
      const p3 = Promise.reject(3);

      // p1.then(value => {
      //   console.log(value);
      // });
      // p2.then(value => {
      //   console.log(value);
      // });
      // p3.catch(reason => {
      //   console.log(reason);
      // });
      // const proAll = Promise.all([p1, p2]);
      // proAll
      //   .then(values => {
      //     console.log('onSolved数据' + values);
      //   })
      //   .catch(reason => {
      //     console.log('onRejected' + reason);
      //   });
      const proRace = Promise.race([p1, p2]);
      proRace
        .then(values => {
          console.log('onSolved数据' + values);
        })
        .catch(reason => {
          console.log('onRejected' + reason);
        });
    </script>
  </body>
</html>
