<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /*
        1.指定回调函数的方式更加灵活
            旧的：必须在启动异步任务之前指定
            promise:启动异步任务=>返回promise对象=>给promise对象绑定回调函数（甚至可以在异步任务结束后指定）

        2、支持链式调用，可以解决回调地狱问题
            什么是回调地狱？回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调函数执行的条件
            回调地狱的缺点？不便于阅读/不便于异常处理
            解决方案？promise链式调用
            终极解决方案？async/await
        */
      //成功的回调函数
      function successCallback(result) {
        console.log('成功' + result);
      }
      //失败的回调函数
      function failureCallback(error) {
        console.log('失败' + result);
      }
      //纯回调函数
      creatFile(audioSettings, successCallback, failureCallback);

      // 使用promise
      const promise = creatFile(audioSettings);
      setTimeout(() => {
        promise.then(successCallback, failureCallback);
      }, 3000);

      // 回调地狱
      doSomething(function(result) {
        doSecondSomething(
          result,
          function(newResult) {
            doThirdSomething(
              newResult,
              function(finalResult) {
                console.log('最终的结果' + finalResult);
              },
              failureCallback,
            );
          },
          failureCallback,
        );
      }, failureCallback);

      //解决promise的链式调用解决回调函数
      doSomething()
        .then(function(result) {
          return doSecondSomething(result);
        })
        .then(function(newResult) {
          return doThirdSomething(newResult);
        })
        .then(function(finalResult) {
          console.log('返回最终结果' + finalResult);
        })
        .catch(error);

      // 2.3 async/await :回调地狱的终极解决方案
      async function request() {
        try {
            const result=await doSomething();

        } catch (error) {
          failureCallback(error);
        }
      }
    </script>
  </body>
</html>
