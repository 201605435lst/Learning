# 同步方法及同步块

- 由于我们使用private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是synchronized关键字，它包括两种方法：synchronized方法和synchronized块
  **同步方法：public synchronized void method(int args){}**
- synchronized方法控制对对象的访问，每一个对象对应一把锁，每个synchronized方法都必须获得使用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，都独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行
  **缺陷：若将一个大的方法申明为synchronized将会影响效率**

## 同步块

- 同步块：synchronized(OBJ){}
- Obj称之为同步监视器
   1. Obj可以是任何对象，但是推荐使用共享资源作为同步监视器
   2. 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this,就是这个对象本身，或者是class
- 同步监视器的执行过程
   1. 第一个线程访问，锁定同步监视器，执行其中代码
   2. 第二个线程访问，发现同步监视器被锁定，无法访问
   3. 第一个线程访问完毕，解锁同步监视器
   4. 第二个线程访问，发现同步监视器没有锁，然后锁定并访问

**1、锁的对象是变化的量，需要增删改的量**

```
         synchronized (account){
             //判断有没有钱
             if(account.money<drawingMoney){
                 System.out.println("余额不足"+Thread.currentThread().getName()+"取不了");
                 return;
             }else{
                 nowMoney=nowMoney+drawingMoney;
                 System.out.println(Thread.currentThread().getName()+"手里的钱有"+nowMoney);
                 account.money=account.money-drawingMoney;
                 System.out.println(account.name+"账户的余额为"+account.money);
             }
         }

```

**2、synchronized 同步方法，锁的是this**
```
    public synchronized void buy() {
        if (tickCount <= 0) {
            System.out.println("买票结束");
            flag = false;
            return;
        }
        System.out.println(Thread.currentThread().getName() + "买到了第" + tickCount-- + "张票");
    }

等价于

public  void buy() {
     synchronized(){
                   if (tickCount <= 0) {
                   System.out.println("买票结束");
                   flag = false;
                   return;
               }
              System.out.println(Thread.currentThread().getName() + "买到了第" + tickCount-- + "张票");
         }
    }


```


```
public class SynchDemo03 {

    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            
            new Thread(() -> {
               synchronized (list){
                   list.add(Thread.currentThread().getName());
               }
            }).start();

        }
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(list.size());
    }
}


```

```
synchronized (list){
    list.add(Thread.currentThread().getName());
}

```