# 常用的线程方法
```
在Java中，线程是用于并发执行任务的基本单位。Java提供了多个线程相关的类和方法，其中一些常用的线程方法包括：

1. `start()`：启动线程并使其进入可运行状态。一旦线程被启动，它将执行`run()`方法中定义的代码。
   
2. `run()`：定义线程的执行逻辑。需要自定义的线程类需要覆盖该方法，以实现线程要执行的操作。`run()`方法通常包含在线程类的定义中。

3. `sleep(long milliseconds)`：使当前线程休眠指定的时间（以毫秒为单位）。在休眠期间，线程暂时停止执行，让出CPU时间给其他线程。

4. `join()`：等待线程完成执行，然后再继续执行当前线程。当一个线程调用另一个线程的`join()`方法时，它将等待目标线程完成后再继续执行。

5. `yield()`：暂停当前线程的执行，并让出CPU时间给其他线程。调用`yield()`的线程将进入就绪状态，让其他具有相同或更高优先级的线程有机会执行。

6. `interrupt()`：中断当前线程。该方法会向线程发送中断请求，但线程是否真正中断取决于线程的处理方式。被中断的线程可以通过检查中断标志来确定是否收到中断请求。

7. `isInterrupted()`：检查当前线程是否被中断。该方法返回一个布尔值，表示线程是否收到中断请求。

8. `currentThread()`：返回当前正在执行的线程对象的引用。

这只是一些常见的线程方法，Java提供了更多用于线程管理、同步和控制的方法和类。线程方法的具体使用方式和效果取决于你的应用程序的需求和设计。

```
## 1、停止线程
```
1、不推荐使用JDK提供的stop()、destroy()方法。
2、推荐线程自己停下来
3、建议使用一个标志位进行终止变量，当flag=false时，则终止线程运行；
```
```
public class StopDemo01 implements Runnable{

    boolean flag=true;

    @Override
    public void run() {
        int i=0;
        while (flag){
            System.out.println("当前计数是"+i++);
        }
    }

    public void stop(){
        this.flag=false;
    }

    public static void main(String[] args) {
        StopDemo01 stopDemo01=new StopDemo01();
        Thread thread=new Thread(stopDemo01);
        thread.start();

        for(int j=1;j<=100000;j++){
//            System.out.println("当前main方法"+j);
            if(j==90000){
                stopDemo01.stop();
//                System.out.println("线程停止了");
            }
        }

    }
}

```

## 2、线程休眠--sleep

- sleep(时间) 指定当前线程阻塞的毫秒数
- sleep存在异常INterruptedException
- sleep时间达到后线程进入就绪状态
- sleep可以模拟网络延时、倒计时等
- 每一个对象都有一个锁，sleep不会释放锁

```
public class SleepDemo01 {

    public static void tenDown() throws InterruptedException {
        int i=10;
        while (true){
            System.out.println("当前计数是"+i--);
            Thread.sleep(1000);
            if(i==0){
                break;
            }
        }
    }


    //模拟倒计时
    public static void main(String[] args)  {
        try {
            tenDown();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

```

## 3、线程礼让 ---yield

```

1、礼让线程，让当前正在执行的线程暂停，但不阻塞；
2、将线程从运行状态变为就绪状态
3、让cpu重新调整，礼让不一定成功，看cpu心情；

```
```
public class YieldDemo01 implements Runnable{

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"线程开始运行");
        Thread.yield();//礼让
        System.out.println(Thread.currentThread().getName()+"线程停止运行");
    }

    public static void main(String[] args) {
            YieldDemo01 yieldDemo01=new YieldDemo01();
            new Thread(yieldDemo01,"A").start();
            new Thread(yieldDemo01,"B").start();
    }

}

```

## 4、线程强制执行 ---join


- Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞；
- 可以想象成插队

```
public class JoinDemo01 implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            System.out.println("Vip线程"+i);
        }
    }

    public static void main(String[] args) {
        JoinDemo01 joinDemo01=new JoinDemo01();
        Thread thread=new Thread(joinDemo01);
        thread.start();

        for (int i = 0; i < 500; i++) {
            System.out.println("这是主线程"+i);
            if(i==200){
                try {
                    thread.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

```