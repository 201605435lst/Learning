## 1.什么是模块化

```
  将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起

  块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信

```

## 2.全局function模式

```
 * 全局函数模式: 将不同的功能封装成不同的全局函数
 * 问题: Global被污染了, 很容易引起命名冲突
```

```
function foo() {
  let data = "我是全局function";
  console.log("foo()", data);
}
```

```
<script type='text/javascript'>
foo()
</script>
```

## 3.namespace模式

```
* namespace模式: 简单对象封装
* 作用: 减少了全局变量
* 问题: 不安全(数据不是私有的, 外部可以直接修改)
```

```
let moudle1={
    date:"这是nameSpace模式",
    fool(){
        console.log(`moudle1 ${this.date}`);
    }
   
}
```

```
<script type='text/javascript'>
moudle1.date="修改了"
moudle1.fool()
</script>
```



## 4._IIFE模式

```
 * IIFE模式: 匿名函数自调用(闭包)
 * IIFE : immediately-invoked function expression(立即调用函数表达式)
 * 作用: 数据是私有的, 外部只能通过暴露的方法操作
 * 问题: 如果当前这个模块依赖另一个模块怎么办?
```

```
//IIFE模式
(function (window) {
  let data = "IIFE模式";
  function foo1() {
    console.log(`fool1() ${data}`);
  }
  function foo2() {
    console.log(`fool2() ${data}`);
    foo3()
  }
  function foo3() {
    console.log(`fool3() 被 fool2() 调用`);
  }
  window.module1 = { foo1, foo2 };
})(window);
```

```
<script type='text/javascript'>
module1.foo1()
module1.foo2()
</script>
```

## 5._IIFE模式增强

```
 * IIFE模式增强 : 引入依赖
 * 这就是现代模块实现的基石
```

```
 (function (window, $) {
    //数据
    let data = 'atguigu.com'
  
    //操作数据的函数
    function foo() { //用于暴露有函数
      console.log(`foo() ${data}`)
      $('body').css('background', 'red')
    }
  
    function bar() {//用于暴露有函数
      console.log(`bar() ${data}`)
      otherFun() //内部调用
    }
  
    function otherFun() { //内部私有的函数
      console.log('otherFun()')
    }
  
    //暴露行为
    window.myModule = {foo, bar}
  })(window, jQuery)
```

```
<script type='text/javascript'>
  myModule.foo()
</script>
```

## 6.**模块化的进化过程**

```
	1. 全局function模式: 
		编码: 全局变量/函数
		问题: 污染全局命名空间, 容易引起命名冲突/数据不安全
	2. namespace模式: 
		编码: 将数据/行为封装到对象中
		解决: 命名冲突(减少了全局变量)
		问题: 数据不安全(外部可以直接修改模块内部的数据)
	3. IIFE模式/增强
		IIFE: 立即调用函数表达式--->匿名函数自调用
		编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口
		引入依赖: 通过函数形参来引入依赖模块
			(function(window, module2){
				var data = 'atguigu'
				function foo() {
				   module2.xxx()
				   console.log('foo()'+data)
				}
				function bar() {
				   console.log('bar()'+data)
				}
				
				window.module = {foo}
			})(window, module2)
```

## 7.js模块化_commonjs(服务器端)

```
 /**
      1. 定义暴露模块:
        module.exports = value;
        exports.xxx = value;
      2. 引入模块:
        var module = require(模块名或模块路径);
     */
```

 **module1.js**

```
/**
 * 使用module.exports = value向外暴露一个对象
 */
module.exports={
    message:'使用module.exports = value向外暴露一个对象',
    fun(){
        console.log(this.message);
    }
}
```

 **module2.js**

```
/* 
    使用module.exports=value向外暴露一个函数 
*/
module.exports = function () {
    console.log("使用module.exports=value向外暴露一个函数 ");
};
```

 **module3.js**

```
/* 
 * 使用exports.xxx = value向外暴露一个对象
 */
exports.fun2={
    data:'使用exports.xxx = value向外暴露一个对象',
    func(){
        console.log(this.data);
    }
}
exports.func3=function(){
    console.log("使用exports.xxx = value向外暴露一个函数");
}
exports.arr=[3,43,5,3,54,56]
```

```
/* 将其他的模块汇集到这个模块 */
let uniq=require('uniq')
let module1=require('./module/module1')
let module2=require('./module/module2')
let module3=require('./module/module3')

module1.fun()

module2()
module3.fun2.func()

module3.func3()
let arr=module3.arr
let result=uniq(arr)
console.log(result);
```

## 8js模块化_commonjs(服务器端)

```
 |-js

  |-dist //打包生成文件的目录

  |-src //源码所在的目录

   |-module1.js

   |-module2.js

   |-module3.js

   |-app.js //应用主源文件

 |-index.html

 |-package.json
```

```
下载browserify

   全局: npm install browserify -g

   局部: npm install browserify --save-dev
```

```
打包处理js:

    browserify js/src/app.js -o js/dist/bundle.js 

页面使用引入:

    <script type="text/javascript" src="js/dist/bundle.js"></script> 


```

## 9._ES6模块化教程

```
1. 下载browserify
  * 全局: npm install browserify -g
  * 局部: npm install browserify --save-dev
```

```
2. 安装babel-cli, babel-preset-es2015和browserify
  * npm install babel-cli browserify -g
	* npm install babel-preset-es2015 --save-dev 
```

```
3. 定义.babelrc文件
	{
    "presets": ["es2015"]
  }
```

```
4. 编译
  * 使用Babel将ES6编译为ES5代码(但包含CommonJS语法) : babel js/src -d js/lib
  * 使用Browserify编译js : browserify js/lib/app.js -o js/lib/bundle.js
```

```
5. 页面中引入测试
  ```
  <script type="text/javascript" src="js/lib/bundle.js"></script>
```





